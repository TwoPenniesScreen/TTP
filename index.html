<!doctype html>
<html lang="en">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1" />
  <title>North Shields — Live Metro Departures</title>

  <!--
    Two Pennies Metro (Live RTI overlay)
    - Background image contains your static slide design.
    - This HTML renders ONLY live elements (departures + clock + status dot + warning banner).

    Hybrid freshness behaviour (Option 3):
    - Data fetch runs every REFRESH_MS.
    - Dot:
        Green pulsing = we have fetched successfully within SHORT_STALE_MS.
        Red solid     = no successful fetch within SHORT_STALE_MS.
    - Short note (only when short-stale):
        "Last update HH:MM"
    - Warning banner (rare, only when genuinely old):
        Shows if the *data content* has not changed for LONG_NOCHANGE_MS.
        Message: "No new data from Nexus — Last update/change was over Xm ago"

    Row layout (plain text, stacked):
      DESTINATION (bold)
      STATUS (caps)
      Current location (title case)
      Due time on right (NOW or "11 min")
  -->

  <style>
    :root {
      --bg-file: url('background.jpg');

      --data-left: 92px;
      --data-right: 92px;
      --data-top: 260px;  /* moved down to clear baked PLATFORM headers */
      --data-bottom: 140px;

      --platform-gap: 120px;

      --row-size: 30px;
      --row-gap: 16px;

      /* Overlay (clock + dot + short-stale note) */
      --overlay-top: 132px;  /* lowered clock to sit below 1 NORTHUMBERLAND PLACE */
      --overlay-right: 20px;
      --overlay-h: 84px;

      --clock-size: 46px;
      --clock-w: 420px;

      --dot-size: 16px;
      --dot-gap: 10px;

      --shortnote-size: 24px;
      --shortnote-gap: 10px;

      --overlay-opacity: 0.65;

      /* Warning banner (only on long no-change) */
      --banner-maxw: 760px;
      --banner-top: 52%;
      --banner-radius: 14px;
      --banner-pad: 18px;
      --banner-font: 22px;
    }

    html, body { height: 100%; margin: 0; }

    body {
      background: var(--bg-file) no-repeat center center;
      background-size: cover;
      font-family: Impact, 'Arial Black', Haettenschweiler, 'Franklin Gothic Condensed', system-ui, sans-serif;
      text-transform: uppercase;
      color: #111;
      overflow: hidden;
    }

    .wrap { position: relative; height: 100%; }

    .data {
      position: absolute;
      left: var(--data-left);
      right: var(--data-right);
      top: var(--data-top);
      bottom: var(--data-bottom);
      display: flex;
      flex-direction: column;
    }

    .platforms {
      display: grid;
      grid-template-columns: 1fr 1fr;
      gap: var(--platform-gap);
    }

    .departures {
      list-style: none;
      padding: 0;
      margin: 0;
      display: grid;
      gap: var(--row-gap);
    }

    .dep {
      display: grid;
      grid-template-columns: 1fr auto;
      gap: 22px;
      font-size: var(--row-size);
      align-items: center;
      padding: 10px 0;
    }

    .dep .left {
      min-width: 0;
      display: grid;
      gap: 4px;
    }

    .dep .dest {
      font-weight: 900;
      min-width: 0;
      overflow: hidden;
      text-overflow: ellipsis;
      white-space: nowrap;
    }

    .dep .status {
      opacity: 0.85;
      letter-spacing: 0.4px;
      white-space: nowrap;
      overflow: hidden;
      text-overflow: ellipsis;
    }

    .dep .loc {
      opacity: 0.85;
      text-transform: none; /* proper case */
      white-space: nowrap;
      overflow: hidden;
      text-overflow: ellipsis;
    }

    .dep .right {
      text-align: right;
      white-space: nowrap;
      font-weight: 900;
    }

    .dep .mins {
      font-variant-numeric: tabular-nums;
      font-feature-settings: "tnum" 1;
      color: #111;
    }

    /* When a train is due: show DUE in red */
    .dep.due .mins {
      color: #b00020;
    }

    /* Hide empty lines to keep the layout clean */
    .dep .status:empty,
    .dep .loc:empty { display: none; }

    .overlay {
      position: absolute;
      top: var(--overlay-top);
      right: var(--overlay-right);
      width: var(--clock-w);
      height: var(--overlay-h);
      pointer-events: none;
      user-select: none;
      opacity: var(--overlay-opacity);
    }

    .clock {
      position: absolute;
      right: 0;
      top: 0;
      width: var(--clock-w);
      text-align: right;
      font-size: var(--clock-size);
      white-space: nowrap;
    }

    /* Fixed-width characters so clock never shifts (even with proportional fonts) */
    .clock .ch {
      display: inline-block;
      width: 0.58em;
      text-align: center;
    }

    .clock .colon { width: 0.30em; }

    .status-dot {
      display: inline-block;
      width: var(--dot-size);
      height: var(--dot-size);
      margin-left: var(--dot-gap);
      border-radius: 50%;
      vertical-align: middle;
      background: #0a8a2a;
    }

    .status-dot.good { animation: pulse 2.4s ease-in-out infinite; }

    .status-dot.bad {
      background: #b00020;
      animation: none;
    }

    @keyframes pulse {
      0% { transform: scale(0.9); opacity: 0.6; }
      50% { transform: scale(1); opacity: 1; }
      100% { transform: scale(0.9); opacity: 0.6; }
    }

    /* Short-stale note under clock */
    .shortnote {
      position: absolute;
      right: 0;
      top: calc(var(--clock-size) + var(--shortnote-gap));
      width: var(--clock-w);
      text-align: right;
      font-size: var(--shortnote-size);
      display: none;
      font-variant-numeric: tabular-nums;
    }

    .shortnote.show { display: block; }

    /* Long no-change warning banner (rare) */
    .banner {
      position: absolute;
      left: 50%;
      top: var(--banner-top);
      transform: translate(-50%, -50%);
      width: min(var(--banner-maxw), calc(100% - 120px));
      background: rgba(176, 0, 32, 0.88);
      color: #fff;
      border-radius: var(--banner-radius);
      padding: var(--banner-pad);
      text-align: center;
      font-size: var(--banner-font);
      letter-spacing: 0.3px;
      text-transform: none;
      display: none;
    }

    .banner.show { display: block; }
    .banner strong { font-weight: 900; }
  </style>
</head>
<body>
  <main class="wrap">

    <section class="data">
      <div class="platforms">
        <article class="platform" id="platform1">
          <ul class="departures" id="platform1-departures">
            <li class="dep">
              <div class="left">
                <div class="dest">No live trains</div>
                <div class="status"></div>
                <div class="loc"></div>
              </div>
              <div class="right"><span class="mins">—</span></div>
            </li>
          </ul>
        </article>

        <article class="platform" id="platform2">
          <ul class="departures" id="platform2-departures">
            <li class="dep">
              <div class="left">
                <div class="dest">No live trains</div>
                <div class="status"></div>
                <div class="loc"></div>
              </div>
              <div class="right"><span class="mins">—</span></div>
            </li>
          </ul>
        </article>
      </div>
    </section>

    <div class="overlay" aria-label="Clock and status">
      <div id="clock" class="clock" data-t="" data-f=""></div>
      <div id="shortnote" class="shortnote"></div>
    </div>

    <div id="banner" class="banner" role="status" aria-live="polite"></div>

  </main>

  <script>
    const STATION = "NSH";
    const REFRESH_MS = 30000;
    const LIMIT = 4; // next 4 trains (can drop to 3 later)

    // Option 3 thresholds:
    const SHORT_STALE_MS = 120000;     // 2 minutes => dot turns red + short note appears
    const LONG_NOCHANGE_MS = 1200000;  // 20 minutes => big red banner appears

    // Last successful fetch + last content change timestamps
    let lastGoodAt = 0;
    let lastGoodHHMM = '';
    let lastChangeAt = 0;

    // Track content hashes per platform (so we can detect "no new data" even when fetch still works)
    let hashP1 = '';
    let hashP2 = '';

    function fmtHHMM(d) {
      const hh = String(d.getHours()).padStart(2, '0');
      const mm = String(d.getMinutes()).padStart(2, '0');
      return `${hh}:${mm}`;
    }

    function minsAgo(msAgo) {
      return Math.max(1, Math.floor(msAgo / 60000));
    }

    function stableHash(obj) {
      // Small + deterministic: only hash the fields we render.
      try {
        if (!obj) return '';
        const services = Array.isArray(obj.services) ? obj.services.slice(0, LIMIT) : [];
        return services.map(s => [
          s?.due ?? s?.dueIn ?? s?.minutes ?? '',
          s?.dest || s?.destination || s?.to || '',
          s?.status || s?.state || s?.event || s?.progress || '',
          s?.location || s?.currentLocation || s?.lastReportedAt || s?.at || s?.via || s?.route || ''
        ].join('|')).join('~');
      } catch {
        return '';
      }
    }

    function renderClock(hh, mm, ss, fresh) {
      const el = document.getElementById('clock');
      if (!el) return;

      const str = `${hh}:${mm}:${ss}`;
      if (el.getAttribute('data-t') === str && el.getAttribute('data-f') === String(fresh)) return;

      el.setAttribute('data-t', str);
      el.setAttribute('data-f', String(fresh));

      const parts = [];
      for (const c of str) {
        if (c === ':') parts.push(`<span class="ch colon">:</span>`);
        else parts.push(`<span class="ch">${c}</span>`);
      }

      parts.push(`<span class="status-dot ${fresh ? 'good' : 'bad'}"></span>`);
      el.innerHTML = parts.join('');
    }

    function tickClock() {
      const d = new Date();
      const hh = String(d.getHours()).padStart(2, '0');
      const mm = String(d.getMinutes()).padStart(2, '0');
      const ss = String(d.getSeconds()).padStart(2, '0');
      const fresh = (Date.now() - lastGoodAt) <= SHORT_STALE_MS;
      renderClock(hh, mm, ss, fresh);
    }

    function updateShortNote() {
      const el = document.getElementById('shortnote');
      if (!el) return;

      const shortStale = (Date.now() - lastGoodAt) > SHORT_STALE_MS;
      if (shortStale && lastGoodHHMM) {
        el.classList.add('show');
        el.textContent = `Last update ${lastGoodHHMM}`;
      } else {
        el.classList.remove('show');
        el.textContent = '';
      }
    }

    function updateBanner() {
      const el = document.getElementById('banner');
      if (!el) return;

      // If we have never seen a change, don't show the banner (prevents scary message on first boot)
      if (!lastChangeAt) {
        el.classList.remove('show');
        el.textContent = '';
        return;
      }

      const age = Date.now() - lastChangeAt;
      const show = age > LONG_NOCHANGE_MS;

      if (show) {
        el.classList.add('show');
        const m = minsAgo(age);
        el.innerHTML = `<strong>No new data from Nexus</strong><br/>Last update/change was over ${m} minutes ago.`;
      } else {
        el.classList.remove('show');
        el.textContent = '';
      }
    }

    function ensureRows(listEl, count) {
      while (listEl.children.length < count) {
        const li = document.createElement('li');
        li.className = 'dep';
        li.innerHTML = `
          <div class="left">
            <div class="dest"></div>
            <div class="status"></div>
            <div class="loc"></div>
          </div>
          <div class="right"><span class="mins"></span></div>
        `;
        listEl.appendChild(li);
      }
      while (listEl.children.length > count) listEl.removeChild(listEl.lastChild);
    }

    function normalizeStatus(raw) {
      if (!raw) return '';
      return String(raw)
        .replace(/_/g, ' ')
        .replace(/\s+/g, ' ')
        .trim()
        .toUpperCase();
    }

    function toTitleCasePlace(str) {
      if (!str) return '';
      return String(str)
        .trim()
        .toLowerCase()
        .split(/\s+/)
        .map(w => {
          if (!w) return w;
          if (w === 'st') return 'St';
          if (w === 'st.') return 'St.';
          if (w.length <= 2 && /^(u|s|e|w|n|ne|nw|se|sw)$/.test(w)) return w.toUpperCase();
          return w.charAt(0).toUpperCase() + w.slice(1);
        })
        .join(' ');
    }

    function renderDepartures(listEl, rows) {
      const data = Array.isArray(rows) ? rows.slice(0, LIMIT) : [];
      const n = Math.max(1, data.length);
      ensureRows(listEl, n);

      if (data.length === 0) {
        const li = listEl.children[0];
        li.querySelector('.dest').textContent = 'No live trains';
        li.querySelector('.status').textContent = '';
        li.querySelector('.loc').textContent = '';
        li.querySelector('.mins').textContent = '—';
        li.classList.remove('due');
        return;
      }

      data.forEach((r, i) => {
        const li = listEl.children[i];

        const due = (r?.due ?? r?.dueIn ?? r?.minutes ?? null);
        const isDue = (due === 0 || due === '0');
        const mins = isDue ? 'DUE' : (due != null ? `${due} min` : '—');
        li.classList.toggle('due', isDue);

        const dest = r?.dest || r?.destination || r?.to || '';
        const statusRaw = r?.status || r?.state || r?.event || r?.progress || '';
        const locRaw = r?.location || r?.currentLocation || r?.lastReportedAt || r?.at || r?.via || r?.route || '';

        li.querySelector('.dest').textContent = dest;
        li.querySelector('.status').textContent = normalizeStatus(statusRaw);
        li.querySelector('.loc').textContent = toTitleCasePlace(locRaw);
        li.querySelector('.mins').textContent = mins;
      });

      // Clear extra rows if the list shrinks
      for (let i = data.length; i < listEl.children.length; i++) {
        const li = listEl.children[i];
        li.querySelector('.dest').textContent = '';
        li.querySelector('.status').textContent = '';
        li.querySelector('.loc').textContent = '';
        li.querySelector('.mins').textContent = '';
        li.classList.remove('due');
      }
    }

    function buildFunctionUrl(platform) {
      // Keep bandwidth minimal; function should handle upstream + caching.
      return `/.netlify/functions/rti?station=${encodeURIComponent(STATION)}&platform=${encodeURIComponent(platform)}&limit=${encodeURIComponent(LIMIT)}`;
    }

    async function fetchPlatform(platform) {
      try {
        const res = await fetch(buildFunctionUrl(platform), { cache: 'no-store' });
        if (!res.ok) return { ok: false };
        const json = await res.json();
        return { ok: true, json };
      } catch {
        return { ok: false };
      }
    }

    async function refreshAll() {
      const [p1, p2] = await Promise.all([
        fetchPlatform(1),
        fetchPlatform(2)
      ]);

      let anyGood = false;
      let anyChange = false;

      if (p1.ok) {
        anyGood = true;
        renderDepartures(document.getElementById('platform1-departures'), p1.json?.services);
        const h = stableHash(p1.json);
        if (h && h !== hashP1) { hashP1 = h; anyChange = true; }
      }

      if (p2.ok) {
        anyGood = true;
        renderDepartures(document.getElementById('platform2-departures'), p2.json?.services);
        const h = stableHash(p2.json);
        if (h && h !== hashP2) { hashP2 = h; anyChange = true; }
      }

      if (anyGood) {
        lastGoodAt = Date.now();
        lastGoodHHMM = fmtHHMM(new Date());
        // First ever good fetch: treat that as a "change" baseline
        if (!lastChangeAt) lastChangeAt = Date.now();
      }

      if (anyChange) {
        lastChangeAt = Date.now();
      }

      updateShortNote();
      updateBanner();
    }

    // Debug / force banner mode
    (function debugFlags() {
      const params = new URLSearchParams(location.search);
      if (params.get('forcebanner') === '1') {
        lastChangeAt = Date.now() - (LONG_NOCHANGE_MS + 60000);
        updateBanner();
      }
    })();

    // Self-tests (run with ?test=1)
    function runTests() {
      const results = [];
      const assert = (name, cond) => results.push({ name, pass: !!cond });

      // buildFunctionUrl should be a string and include platform
      const u = buildFunctionUrl(2);
      assert('buildFunctionUrl returns string', typeof u === 'string' && u.includes('platform=2'));

      // clock render should include status-dot
      renderClock('02','00','39', true);
      assert('clock includes dot', document.getElementById('clock')?.querySelectorAll('.status-dot')?.length === 1);

      // departures render creates correct structure
      const ul = document.createElement('ul');
      ensureRows(ul, 1);
      assert('row has dest/status/loc', !!ul.querySelector('.dest') && !!ul.querySelector('.status') && !!ul.querySelector('.loc'));

      console.table(results);
      const failed = results.filter(r => !r.pass);
      if (failed.length) console.warn('Tests failed:', failed);
    }

    (function initFlags() {
      const params = new URLSearchParams(location.search);
      if (params.get('test') === '1') runTests();
    })();

    // Loops
    tickClock();
    updateShortNote();
    updateBanner();

    setInterval(tickClock, 1000);
    setInterval(() => {
      updateShortNote();
      updateBanner();
    }, 2000);

    refreshAll();
    setInterval(refreshAll, REFRESH_MS);
  </script>
</body>
</html>
